%\section{Feature Featherweight Java}\label{seq:ffj}

\subsection{Syntax}
The Syntax of \ac{FFJ} is a straightfoward \ac{FOP} extension of \ac{FJ}. Due to the lack
of space we will not present the formal definition \ac{FJ}, but instead we follow
the same scheme of the \ac{FFJ} original definition in \cite{apel_feature_2008} and present
the modified rules highlited with \hlmod{shaded yellow boxes} and new rules highlighted by
\hlnew{shaded purple boxes}.

\begin{table}[!ht]
    \begin{tabularx}{.62\textwidth}{l|}
            \texttt{CD}~::= \hfill \textit{class declarations:}\\
            \quad \texttt{class\ C~extends~C\ \{\={C} \={f}; K \={M}\}} \\  \\
            \hlnew{\texttt{CR}~::=} \hfill \textit{class refinements:}\\
            \quad \hlnew{\texttt{refines~class R \{\={C} \={f}; KD \={M} \={MR}\}}} \\ \\
            \texttt{K}~::=  \hfill\textit{constructor declarations:}\\
            \quad \texttt{C(\={C}~\={f})\{super(\={f});~this.\={f}=\={f};\}}\\\\
            \hlnew{\texttt{KD}~::=} \hfill\textit{constructor refinements:} \\
            \quad \hlnew{\texttt{refines~C(\={E}~\={h}, \={C} \={f})\{original(\={f}); this.\={f}=\={f};\}}} \\\\
            \texttt{M}~::= \hfill\textit{method declarations:}\\
            \quad \texttt{C~m~(\={C}~\={x})\ \{return~e;\}}
    \end{tabularx}
    \begin{tabularx}{.4\textwidth}{l}
            \hlnew{\texttt{MR}~::=} \hfill \textit{method refinements:}\\
            \quad \hlnew{\texttt{refines C~m~(\={C}~\={x}) \{return~e;\}}}\\ \\
            \texttt{e}~::= \hfill \textit{expressions:}\\
            \quad \texttt{x} \hfill\textit{variable}\\ 
            \quad \texttt{e.f} \hfill\textit{field access}\\
            \quad \texttt{e.m(\={e})} \hfill\textit{method invocation}\\
            \quad \texttt{new~C(\={e})} \hfill\textit{object creation}\\
            \quad \texttt{(C)e} \hfill\textit{cast}\\ \\
            \texttt{v}~::= \hfill \textit{values:}\\
            \quad \texttt{new~C(\={e})} \hfill\textit{object creation}
    \end{tabularx}
    \quad
    \caption{\ac{FFJ} Syntax}
    \label{abstractsyntax}
\end{table}
%\end{center}


The syntax of \ac{FFJ} constructs is given at Table~\ref{abstractsyntax}. The metavariables
\texttt{A}, \texttt{B}, \texttt{C}, \texttt{D} and \texttt{E} ranges over class names, \texttt{f} and \texttt{g} ranges over
field names; \texttt{m} ranges method name; \texttt{x} ranges over variable, \texttt{v} ranges over
values, \texttt{feat} ranges over feature names and 
\texttt{R}, \texttt{S} and \texttt{P} ranges over refinement name, which are represented by \texttt{C@feat}.
We assume a that the set of variables includes the special variable \texttt{this}, which
cannot be used as the name of an argument of a method.

We write \texttt{\=f} as a shorthand for a possible empty sequence \texttt{f\textsubscript1}, \dots, \texttt{f\textsubscript{n}} 
and similarly for \texttt{\=C}, \texttt{\=x}, \texttt{\=e}, etc. We abbreviate the operations on pairs of sequences
``\texttt{\=C~\=f}'' for ``\texttt{C\textsubscript1~f\textsubscript1},\dots, \texttt{C\textsubscript{n}~f\textsubscript{n}}''
and ``\texttt{this.\=f=\=f;}'' as a shorthand for 
``\texttt{this.\=f\textsubscript1=\=f\textsubscript1;} \dots, \texttt{this.\=f\textsubscript{n}=\=f\textsubscript{n};}''.
We write empty sequence as $\bullet$.


A class declaration \texttt{class\ C~extends~D\ \{\={C} \={f}; K \={M}\}} 
introduces a class \texttt{C} with superclass \texttt{D}. This class has fields \texttt{\=f}
of type \texttt{C}, a constructor \texttt{K} and methdos \texttt{\=M}. The fields of class \texttt{C}
is \texttt{\=f} added to the fields of its superclass \texttt{D}, all of them must have distinct names.
Methods, in the other, hand may override another superclass method with the same name.
Method override in both \ac{FJ} \ac{FFJ} is basically method rewrite. 
Methods are uniquely identified by its name, i.e. overload is not supported.
%como nao tem como explicar as fields de class refinement aqui, vamos deixar pra definir tudo com calma somente na
%sessao de lookup functions

A class refinement \texttt{refines~class~R~\{\={C}~\={f};~KD~\={M}~\={MR}\}}
introduces a refinement of the class \texttt{C}. 
This refinement contains the fields  \texttt{\=f} of type \texttt{\=C}, 
a constructor refinement \texttt{KR}, methods declarations \texttt{\=M} and method refinements \texttt{\={MR}}.
Like class declarations, the fields of a class refinement \texttt{R} are added to the fields of its predecessor, which
is explained in more detail in Section \ref{subsec:lookup}.

Constructor declaration \texttt{C(\={C}~\={f})\{super(\={f}); this.\={f}=\={f};\}} and a constructor refinement 
\texttt{refines~C(\={E}~\={h}, \={C}~\={f}) \{original(\={f}); this.\={f}=\={f};\}} introduces a constructor with 
for the class \texttt{C} with fields \texttt{\=f} of type \texttt{\=C}. The constructor declaration body is simply 
a list of assignment of the arguments with its correspondent field preceded by calling its superclass constructor with the correspondent arguments.
The constructor refinement only differs from constructor declaration that instead of calling the superclass constructor
it will call its predecessor constructor (denoted by \texttt{original}).

Method declaration \texttt{C~m~(\={C}~\={x})\ \{return~e;\}} and method refinement \texttt{refines C~m~(\={C}~\={x})\ \{return~e;\}} 
introduces a method \texttt{m} of return type \texttt{C} with arguments \texttt{\={C}~\={x}} and body \texttt{e}.
Method declarations should only appear inside a class declaration or a class refinement, whereas method refinement should only appear
inside a class refinement. There is such a distinction between method declaration and method refinement for allowing the type checker
to recognize the difference between method refinement and inadvertent overriding/replacement.

A class table \textsf{CT} is a mapping from class names \texttt{C} to class declarations \texttt{CD}.
A refinement table RT is a mapping from refinement name \texttt{C~@~feat} to refinement declarations.
An \ac{FFJ} program consists of a triple (\textsf{CT}, RT, \texttt{e}) of a class table, a refinement table
and an expression. Throughout the rest of the paper the \textsf{CT} and the RT are assumed to be always fixed to lighten the notation.

\subsection{Lookup Functions}\label{subsec:lookup}

In \ac{FFJ} as well as in \ac{FJ} types are classes and classes have a subclass relation defined by the syntax of class declaration.
To navigate this subclass relation in the \textsf{CT}, the auxiliary operator \texttt{<:} is given in \ref{table:sub_pred}, this operator is 
the reflexive and transitive closure of the subclass relation.

The \textsf{CT} is expected to satisfy some sanity conditions:
\begin{itemize}
	\item  \textsf{CT}~(\texttt{C}) = \texttt{class C}$\ldots$ for every \texttt{C} $\in$ dom(\textsf{CT})
	\item \texttt{Object} $\notin$ dom(\textsf{CT})
	\item for every class name \texttt{C}~(except \texttt{Object}) appearing anywhere
		in \textsf{CT}, we have \texttt{C} $\in$ dom(\textsf{CT})
	\item there are no cycles in the subtype relation induced by \textsf{CT}, i.e., the
		relation \texttt{<:} is antisymmetric
\end{itemize}

In Overhaul \ac{FFJ} we fetch the refinement precedence via its position in the \textsf{RT}, i.e.
if a refinement of a class appears first in the \textsf{RT} it will be applied first. To navigate the
precedence we define the \textit{pred} function. The \textit{pred} function will get a class refinement as an argument,
filter refinements of a class \texttt{C} as \texttt{\=R}, fetch the index $n$ of \texttt{R} in \texttt{\=R} 
and return the element \texttt{P} at the position $n-1$ in \texttt{\=R}. Notice that \textit{pred} is a partial function
because it is not defined if the a refinement is the first refinement.


\begin{table}[!ht]
    \raggedright \textit{Predecessor}\\
	\centering
    \begin{tabular}{c}
        \rowcolor{shpurple}
        \inferrule{\texttt{R} = \texttt{C@feat} \\
                  filter~\texttt{C}~\textsf{RT}~=~\texttt{\=R} \\
                  index~\texttt{R}~\texttt{\=R}~=~n\\
                  get~(n-1)~\texttt{\=R}~=~\texttt{P}}
        {\textit{pred}~\texttt{R}~=\texttt{P}}
    \end{tabular}

    \raggedright \textit{Subtyping}\\
	\centering
	\begin{tabular}{c@{\qquad}c@{\qquad}c}
		\inferrule{ }{\texttt{C~<:~C}} & 
		\inferrule{\texttt{C <: D} \qquad \texttt{C <: E}}
		{\texttt{C~<:~E}} &
		\inferrule{\texttt{class~C~extends~D~\{~\ldots~\}}}
		{\texttt{C~<:~D}} \\
	\end{tabular}
    \label{table:sub_pred}
    \qquad\qquad
    \caption{Subtyping and Predecessor Relations}
\end{table}

\begin{table}[ht!]
	\centering
	\def\arraystretch{2.5}
	\begin{tabular}{|c|}
        \hline
		$fields~($\texttt{Object}$)=\bullet$ \\
		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad fields~(D)=\bar{D}\ \bar{g}}
		{fields~(C)=\bar{D}\ \bar{g},\ \bar{C}\ \bar{f}}\\
        \hline
	\end{tabular}
    \label{field}
    \quad\quad
    \caption{Field lookup}
\end{table}


\begin{table}[h!]
	\centering
	\def\arraystretch{3}
	\begin{tabular}{|c|}
        \hline
		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad B\ m~(\bar{B}\ \bar{x})\{return\ e;\}\in~\bar{M}} {mtype~(m,~C)=\bar{B}\rightarrow~B} \\
		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad m\notin~\bar{M}}
		{mtype~(m,~C)=mtype~(m,~D)} \\
        \hline
	\end{tabular}
    \quad
    \label{mtypelookup}
    \caption{Method type lookup}
\end{table}

\begin{table}[h!]
	\centering
	\def\arraystretch{3}
	\begin{tabular}{c}
		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad B\ m~(\bar{B}\ \bar{x})\{return\
	e;\}\in~\bar{M}}
		{mbody~(m,~C)=\bar{x}.e} \\

		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad m\notin~\bar{M}}
		{mbody~(m,~C)=mbody~(m,~D)} \\
	\end{tabular}
    \label{mbodylookup}
    \quad
    \caption{Method body lookup}
\end{table}


\begin{table}[h!]
	\centering
	\def\arraystretch{3}
    \caption{Expression typing}
	\begin{tabular}{cr}
		$\Gamma \vdash x:\Gamma(x)$& (T-Var)\\

		\inferrule{\Gamma \vdash e_{0}:C_{0}\qquad fields~(C_{0})=\bar{C}\
		\bar{f}}
		{\Gamma \vdash e_{0}.f_{i}:C_{i}} & (T-Field)\\

		\inferrule{\Gamma \vdash e_{0}:C_{0}\qquad
			mtypes~(m,~C_{0})=\bar{D}\rightarrow C\qquad \Gamma \vdash
		\bar{e} : \bar{C} \qquad \bar{C}~<:~\bar{D}}
		{\Gamma \vdash e_{0}.m(\bar{e}):C} & (T-Invk)\\

		\inferrule{fields(C)=\bar{D}\ \bar{f}\qquad \Gamma \vdash
		\bar{e}:\bar{C} \qquad \bar{C}~<:~\bar{D}}
		{\Gamma \vdash new\ C(\bar{e}):C} & (T-New)\\

		\inferrule{\Gamma \vdash e_{0}:D \qquad D~<:~C}
		{\Gamma \vdash (C)~e_{0}: C} & (T-UCast)\\

		\inferrule{\Gamma \vdash e_{0}:D\qquad C~<:~D \qquad C \neq D}
		{\Gamma \vdash (C)~e_{0}:C} & (T-DCast)\\

		\inferrule{\Gamma \vdash e_{0}:D\qquad C~\nless :~D \qquad D~\nless:~C 
		\qquad stupid\ warning}
		{\Gamma \vdash (C)~e_0:C} & (T-SCast)\\

	\end{tabular}
\quad
\label{exptyping}
\end{table}

\begin{table}[h!]
	\centering
	\def\arraystretch{3}
    \caption{Expression computation}
	\begin{tabular}{cr}
		\inferrule{fields~(C) = \bar{C} \bar{f}}
        {(new\ C(\bar{e})).f_i \rightarrow e_i} & (R-Field) \\

		\inferrule{mbody~(m, C) = \bar{x}.e_0}
        {(new\ C~(\bar{e})).m~(\bar{d}) \rightarrow[\bar{d}/\bar{x}, new\ C~(\bar{e})/this]e_0} & (R-Invk)\\
		\inferrule{C<:D}
        {(D)(new\ C~(\bar{e})) \rightarrow new\ C~(\bar{e})} & (R-Cast)\\
	\end{tabular}
\quad
\label{expcomput}
\end{table}

\begin{table}[h!]
	\centering
	\def\arraystretch{3}
    \caption{Congruence}
	\begin{tabular}{cr}
		\inferrule{e_0 \rightarrow e_0'}
        {e_0.f\rightarrow e_0'.f} & (RC-Field) \\
		\inferrule{e_0 \rightarrow e_0'}
        {e_0.m~(\bar{e})\rightarrow e_0'.m~(\bar{e})} & (RC-Invk-Recv) \\
		\inferrule{e_i \rightarrow e_i'}
        {e_0.m~(\dots, e_i, \dots) \rightarrow e_0'.m~(\dots, e_i, \dots)} & (RC-Invk-Arg) \\
		\inferrule{e_i \rightarrow e_i'}
        {new\ C~(\dots, e_i, \dots) \rightarrow new\ C~(\dots, e_i', \dots)} & (RC-New-Arg) \\
		\inferrule{e_0 \rightarrow e_0'}
        {(C)e_0 \rightarrow (C)e_0'} & (RC-Cast) \\

	\end{tabular}
\quad
\label{expcongr}
\end{table}

\subsection{Typing}

The typing rules for expressions are in Table~\ref{exptyping}. An environment
$\Gamma$ is a finite mapping from variables to types, written $\bar{c}:\bar{C}$.
The typing judgment for expressions has the form $\Gamma \vdash e: C$, read ``in
the environment $\Gamma$, expression $e$ has type $C$''.

\subsection{Computation}
The reduction relation is of ther form $e \rightarrow e'$, read ``expression
$e$ reduces to expression $e'$ in one step'', We write $\rightarrow *$ for the
reflexisive and transitive closure of $\rightarrow$.

The reduction rules are given in~\ref{expcomput}. There are three reduction
rules, one for field acess, one for method invocation, and one for casting.
These were already explained above. We write $[\bar{d}=\bar{x}, e=y]e_0$ for
the result of replacing $x_1$ by $d_1$, $x_2$ by $d_2, \dots, x_n$ by $d_n$, and $y$ by $e$ in
the expression $e_0$.

Notice again that with the absense of side effects, there is no need of stack
or heap for variable binding. 

The reduction rules may be applied at any point in an expression, so we also
need the obvious congruence rules.

