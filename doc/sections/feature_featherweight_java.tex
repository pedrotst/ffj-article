%\section{Feature Featherweight Java}\label{seq:ffj}

\subsection{Syntax}
The Syntax of \ac{FFJ} is a straightfoward \ac{FOP} extension of \ac{FJ}. Due to the lack
of space we will not present the formal definition \ac{FJ}, but instead we follow
the same scheme of the \ac{FFJ} original definition in \cite{apel_feature_2008} and present
the modified rules highlited with \hlmod{shaded yellow boxes} and new rules highlighted by
\hlnew{shaded purple boxes}.

\begin{table}[!ht]
    \begin{tabularx}{.62\textwidth}{l|}
            \texttt{CD}~::= \hfill \textit{class declarations:}\\
            \quad \texttt{class\ C~extends~C\ \{\={C} \={f}; K \={M}\}} \\  \\
            \hlnew{\texttt{CR}~::=} \hfill \textit{class refinements:}\\
            \quad \hlnew{\texttt{refines~class R \{\={C} \={f}; KD \={M} \={MR}\}}} \\ \\
            \texttt{K}~::=  \hfill\textit{constructor declarations:}\\
            \quad \texttt{C(\={C}~\={f})\{super(\={f});~this.\={f}=\={f};\}}\\\\
            \hlnew{\texttt{KD}~::=} \hfill\textit{constructor refinements:} \\
            \quad \hlnew{\texttt{refines~C(\={E}~\={h}, \={C} \={f})\{original(\={f}); this.\={f}=\={f};\}}} \\\\
            \texttt{M}~::= \hfill\textit{method declarations:}\\
            \quad \texttt{C~m~(\={C}~\={x})\ \{return~e;\}}
    \end{tabularx}
    \begin{tabularx}{.4\textwidth}{l}
            \hlnew{\texttt{MR}~::=} \hfill \textit{method refinements:}\\
            \quad \hlnew{\texttt{refines C~m~(\={C}~\={x}) \{return~e;\}}}\\ \\
            \texttt{e}~::= \hfill \textit{expressions:}\\
            \quad \texttt{x} \hfill\textit{variable}\\ 
            \quad \texttt{e.f} \hfill\textit{field access}\\
            \quad \texttt{e.m(\={e})} \hfill\textit{method invocation}\\
            \quad \texttt{new~C(\={e})} \hfill\textit{object creation}\\
            \quad \texttt{(C)e} \hfill\textit{cast}\\ \\
            \texttt{v}~::= \hfill \textit{values:}\\
            \quad \texttt{new~C(\={e})} \hfill\textit{object creation}
    \end{tabularx}
    \quad
    \caption{\ac{FFJ} Syntax}
    \label{abstractsyntax}
\end{table}
%\end{center}


The syntax of \ac{FFJ} constructs is given at Table~\ref{abstractsyntax}. The metavariables
\texttt{A}, \texttt{B}, \texttt{C}, \texttt{D} and \texttt{E} ranges over class names, \texttt{f} and \texttt{g} ranges over
field names; \texttt{m} ranges method name; \texttt{x} ranges over variable, \texttt{v} ranges over
values, \texttt{feat} ranges over feature names and 
\texttt{R}, \texttt{S} and \texttt{P} ranges over refinement name, which are represented by \texttt{C@feat}.
We assume a that the set of variables includes the special variable \texttt{this}, which
cannot be used as the name of an argument of a method.

We write \texttt{\=f} as a shorthand for a possible empty sequence \texttt{f\textsubscript1}, \dots, \texttt{f\textsubscript{n}} 
and similarly for \texttt{\=C}, \texttt{\=x}, \texttt{\=e}, etc. We abbreviate the operations on pairs of sequences
``\texttt{\=C~\=f}'' for ``\texttt{C\textsubscript1~f\textsubscript1},\dots, \texttt{C\textsubscript{n}~f\textsubscript{n}}''
and ``\texttt{this.\=f=\=f;}'' as a shorthand for 
``\texttt{this.\=f\textsubscript1=\=f\textsubscript1;} \dots, \texttt{this.\=f\textsubscript{n}=\=f\textsubscript{n};}''.
We write empty sequence as $\bullet$.


A class declaration \texttt{class\ C~extends~D\ \{\={C} \={f}; K \={M}\}} 
introduces a class \texttt{C} with superclass \texttt{D}. This class has fields \texttt{\=f}
of type \texttt{C}, a constructor \texttt{K} and methdos \texttt{\=M}. The fields of class \texttt{C}
is \texttt{\=f} added to the fields of its superclass \texttt{D}, all of them must have distinct names.
Methods, in the other, hand may override another superclass method with the same name.
Method override in both \ac{FJ} \ac{FFJ} is basically method rewrite. 
Methods are uniquely identified by its name, i.e. overload is not supported.
%como nao tem como explicar as fields de class refinement aqui, vamos deixar pra definir tudo com calma somente na
%sessao de lookup functions

A class refinement \texttt{refines~class~R~\{\={C}~\={f};~KD~\={M}~\={MR}\}}
introduces a refinement of the class \texttt{C}. 
This refinement contains the fields  \texttt{\=f} of type \texttt{\=C}, 
a constructor refinement \texttt{KR}, methods declarations \texttt{\=M} and method refinements \texttt{\={MR}}.
Like class declarations, the fields of a class refinement \texttt{R} are added to the fields of its predecessor, which
is explained in more detail in Section \ref{subsec:lookup}.

Method declaration \texttt{C~m~(\={C}~\={x})\ \{return~e;\}} and method refinement \texttt{refines C~m~(\={C}~\={x})\ \{return~e;\}} 
introduces a method \texttt{m} of return type \texttt{C} with arguments \texttt{\={C}~\={x}} and body \texttt{e}.
Method declarations should only appear inside a class declaration or a refinement declaration.

Method refinement \texttt{refines C~m~(\={C}~\={x})\ \{return~e;\}}, similarly, introduces a method \texttt{m} of return type \texttt{C}
with arguments \texttt{\={C}~\={x}} and body \texttt{e}. Method refinements should only appear inside a refinement declaration.

A class table CT is a mapping from class names \texttt{C} to class declarations \texttt{CD}.
A refinement table RT is a mapping from refinement name \texttt{C~@~feat} to refinement declarations.
An \ac{FFJ} program consists of a triple (CT, RT, \texttt{e}) of a class table, a refinement table
and an expression. Throughout the rest of the paper the CT and the RT are assumed to be always fixed to lighten the notation.

\subsection{Lookup Functions}\label{subsec:lookup}
\begin{table}[!h]
    \raggedright \textit{Predecessor}\\
	\centering
    \begin{tabular}{c}
        \rowcolor{shpurple}
        \inferrule{index~\texttt{R RT} =\ n\\
                  get~(n-1)~\texttt{RT} = \texttt{P}}
        {\textit{pred } \texttt{R} =\texttt{P}}
    \end{tabular}

    \raggedright \textit{Subtyping}\\
	\centering
	\begin{tabular}{c@{\qquad}c@{\qquad}c}
		\inferrule{ }{\texttt{C~<:~C}} & 
		\inferrule{\texttt{C <: D} \qquad \texttt{C <: E}}
		{\texttt{C~<:~E}} &
		\inferrule{\texttt{class~C~extends~D~\{~\ldots~\}}}
		{\texttt{C~<:~D}} \\
	\end{tabular}
    \label{subtyping}
    \qquad\qquad
    \caption{Subtyping and Predecessor Relations}
\end{table}

\begin{table}[ht!]
	\centering
	\def\arraystretch{2.5}
	\begin{tabular}{|c|}
        \hline
		$fields~($\texttt{Object}$)=\bullet$ \\
		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad fields~(D)=\bar{D}\ \bar{g}}
		{fields~(C)=\bar{D}\ \bar{g},\ \bar{C}\ \bar{f}}\\
        \hline
	\end{tabular}
    \label{field}
    \quad\quad
    \caption{Field lookup}
\end{table}


\begin{table}[h!]
	\centering
	\def\arraystretch{3}
	\begin{tabular}{|c|}
        \hline
		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad B\ m~(\bar{B}\ \bar{x})\{return\ e;\}\in~\bar{M}} {mtype~(m,~C)=\bar{B}\rightarrow~B} \\
		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad m\notin~\bar{M}}
		{mtype~(m,~C)=mtype~(m,~D)} \\
        \hline
	\end{tabular}
    \quad
    \label{mtypelookup}
    \caption{Method type lookup}
\end{table}

\begin{table}[h!]
	\centering
	\def\arraystretch{3}
	\begin{tabular}{c}
		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad B\ m~(\bar{B}\ \bar{x})\{return\
	e;\}\in~\bar{M}}
		{mbody~(m,~C)=\bar{x}.e} \\

		\inferrule{class\ C\ extends\ D~\{\bar{C}\ \bar{f};\ K\
		\bar{M}\} \qquad m\notin~\bar{M}}
		{mbody~(m,~C)=mbody~(m,~D)} \\
	\end{tabular}
    \label{mbodylookup}
    \quad
    \caption{Method body lookup}
\end{table}


\begin{table}[h!]
	\centering
	\def\arraystretch{3}
    \caption{Expression typing}
	\begin{tabular}{cr}
		$\Gamma \vdash x:\Gamma(x)$& (T-Var)\\

		\inferrule{\Gamma \vdash e_{0}:C_{0}\qquad fields~(C_{0})=\bar{C}\
		\bar{f}}
		{\Gamma \vdash e_{0}.f_{i}:C_{i}} & (T-Field)\\

		\inferrule{\Gamma \vdash e_{0}:C_{0}\qquad
			mtypes~(m,~C_{0})=\bar{D}\rightarrow C\qquad \Gamma \vdash
		\bar{e} : \bar{C} \qquad \bar{C}~<:~\bar{D}}
		{\Gamma \vdash e_{0}.m(\bar{e}):C} & (T-Invk)\\

		\inferrule{fields(C)=\bar{D}\ \bar{f}\qquad \Gamma \vdash
		\bar{e}:\bar{C} \qquad \bar{C}~<:~\bar{D}}
		{\Gamma \vdash new\ C(\bar{e}):C} & (T-New)\\

		\inferrule{\Gamma \vdash e_{0}:D \qquad D~<:~C}
		{\Gamma \vdash (C)~e_{0}: C} & (T-UCast)\\

		\inferrule{\Gamma \vdash e_{0}:D\qquad C~<:~D \qquad C \neq D}
		{\Gamma \vdash (C)~e_{0}:C} & (T-DCast)\\

		\inferrule{\Gamma \vdash e_{0}:D\qquad C~\nless :~D \qquad D~\nless:~C 
		\qquad stupid\ warning}
		{\Gamma \vdash (C)~e_0:C} & (T-SCast)\\

	\end{tabular}
\quad
\label{exptyping}
\end{table}

\begin{table}[h!]
	\centering
	\def\arraystretch{3}
    \caption{Expression computation}
	\begin{tabular}{cr}
		\inferrule{fields~(C) = \bar{C} \bar{f}}
        {(new\ C(\bar{e})).f_i \rightarrow e_i} & (R-Field) \\

		\inferrule{mbody~(m, C) = \bar{x}.e_0}
        {(new\ C~(\bar{e})).m~(\bar{d}) \rightarrow[\bar{d}/\bar{x}, new\ C~(\bar{e})/this]e_0} & (R-Invk)\\
		\inferrule{C<:D}
        {(D)(new\ C~(\bar{e})) \rightarrow new\ C~(\bar{e})} & (R-Cast)\\
	\end{tabular}
\quad
\label{expcomput}
\end{table}

\begin{table}[h!]
	\centering
	\def\arraystretch{3}
    \caption{Congruence}
	\begin{tabular}{cr}
		\inferrule{e_0 \rightarrow e_0'}
        {e_0.f\rightarrow e_0'.f} & (RC-Field) \\
		\inferrule{e_0 \rightarrow e_0'}
        {e_0.m~(\bar{e})\rightarrow e_0'.m~(\bar{e})} & (RC-Invk-Recv) \\
		\inferrule{e_i \rightarrow e_i'}
        {e_0.m~(\dots, e_i, \dots) \rightarrow e_0'.m~(\dots, e_i, \dots)} & (RC-Invk-Arg) \\
		\inferrule{e_i \rightarrow e_i'}
        {new\ C~(\dots, e_i, \dots) \rightarrow new\ C~(\dots, e_i', \dots)} & (RC-New-Arg) \\
		\inferrule{e_0 \rightarrow e_0'}
        {(C)e_0 \rightarrow (C)e_0'} & (RC-Cast) \\

	\end{tabular}
\quad
\label{expcongr}
\end{table}


\begin{itemize}
	\item $ CT~(C)=class\ C\ldots$ for every $C\in dom(CT)$
	\item \texttt{Object}$\notin dom(CT)$
	\item for every class name $C$~(except \texttt{Object}) appearing anywhere
		in CT, we have $C\in dom(CT)$
	\item there are no cycles in the subtype relation induced by CT, i.e., the
		relation <: is antisymmetric
\end{itemize}

\subsection{Typing}

The typing rules for expressions are in Table~\ref{exptyping}. An environment
$\Gamma$ is a finite mapping from variables to types, written $\bar{c}:\bar{C}$.
The typing judgment for expressions has the form $\Gamma \vdash e: C$, read ``in
the environment $\Gamma$, expression $e$ has type $C$''.

\subsection{Computation}
The reduction relation is of ther form $e \rightarrow e'$, read ``expression
$e$ reduces to expression $e'$ in one step'', We write $\rightarrow *$ for the
reflexisive and transitive closure of $\rightarrow$.

The reduction rules are given in~\ref{expcomput}. There are three reduction
rules, one for field acess, one for method invocation, and one for casting.
These were already explained above. We write $[\bar{d}=\bar{x}, e=y]e_0$ for
the result of replacing $x_1$ by $d_1$, $x_2$ by $d_2, \dots, x_n$ by $d_n$, and $y$ by $e$ in
the expression $e_0$.

Notice again that with the absense of side effects, there is no need of stack
or heap for variable binding. 

The reduction rules may be applied at any point in an expression, so we also
need the obvious congruence rules.

