\section{Discussion}\label{seq:impl}

Our experience on formalizing \ac{FFJ} 
using Coq not only enabled us to better understand \ac{FFJ}, 
but also helped on improving and simplifying its original specification 
and \emph{handwriting proofs}. For instance, our version expects 
explicit annotations to relate class refinements to the 
corresponding features---this is similar to the 
approach discussed by Delaware at al.~\cite{delaware:fse-2009}, 
where features appear as modular composition units. 
Here, the idea of syntactically including the feature name in the annotation 
of class refinements provides a trivial way to 
reference the refinement, simplifying the lookup functions.

Actually, our process started by formalizing \ac{FJ}, %TODO Fornecer alguma intuicao do pq precisou formalizar FJ primeiro - ja nao existia?
and than evolving this formalization towards \ac{FFJ}. 
To make our language implementation and proofs more clear, 
we decided not to use some advanced language features 
and recent Coq idioms, such as those discussed in \emph{Meta-Theory \`{a} la Carte}~\cite{}. %TODO incluir citacao 
For this reason, and considering that data types in Coq are not extensible, 
we have to \emph{copy and paste} our original \ac{FJ} definition 
to our \ac{FFJ} Coq source code repository. Our original \ac{FJ} 
definition includes 22 inductive definitions, 31 lemmas, and 
19 tactics. Instead, our \ac{FFJ} specification includes 
39 inductive definitions, 61 lemmas, and 34 new tactics. Due to our 
design decisions detailed in the previous sections, 
we were able to preserve all \ac{FJ} lemmas in \ac{FFJ}---though 
we had to change the proofs related to four of the original \ac{FJ} 
lemmas. That is, even with the naive approach for reusing 
definitions, our decisions related to \ac{FFJ} 
allowed us to preserve several definitions present 
in our \ac{FJ} specification. 

We believe that formalizing a feature-oriented programming language might 
help other researchers to verify software product 
line (SPL) properties considering not only high level 
variability artifacts of an SPL (such as feature and configuration 
models), but also a core calculus of programming 
languages (such as \ac{FFJ}). 
For instance, several works discuss the \emph{safe evolution 
of product lines}, formalizing it as a theory of SPL refinement~\cite{theory-pl-refinement, partially-safe-evolution-pl}. 
Such theory assumes that an SPL consists of three main artifacts, variability model, configuration model, and the asset base (e.g., source code), which builds upon a language having well-formedness notions and also refinement rules, in the sense of behaviour preservation. 
In this paper, we discussed and implemented a notion of well-formedness rules for \ac{FFJ}, postponing 
the meaning of \ac{FFJ} refinements to a future work. 
A direct application of the safe evolution concept is deriving 
refinement transformation templates~\cite{safe-evolution-templates-pl}, 
establishing the necessary conditions in which one can safely evolve the SPL, 
without introducing behavioural changes. For instance, splitting an implementation asset, such as a class, in two, provided that the novel implementation (the two classes) preserve the behaviour of the original one. 
These existing SPL refinement templates have been proposed without assuming a particular 
programming language for asset implementation, so their expressiveness is limited by what can be stated 
in a general way for any programming language. 
By plugging this formalization into the theory, we can further derive refinement templates specific to \ac{FFJ}, 
providing better support for SPLs written in such language. Moreover, another possibility is using the extraction mechanism of Coq to generate verified implementations for such transformation operations.


